# 좋은 테스트 원칙

### 테스트의 비밀

> 1. 한번 작성된 테스트 코드는 영원히 유지보수 해야한다. (clean code 원칙)
> 2. 내부 구현 사항을 테스트하면 안된다. (실제 코드와 함께 수정되기 때문에 내부의 변수, 함수 이름들까지 테스트하면 비효율적)
> 3. 재사용성을 높여야한다. (테스트 유틸리티)
> 4. 배포용 코드와 철저히 분리 해아한다.
> 5. 테스트 코드를 통한 문서화 (내가 작성한 테스트코드만 바라봤을때 한눈에 들어오는 좋은 문서화 효과)

### 좋은 테스트의 구조

> - 시작 단계 beforeEach, beforeAll / 테스트 단계 / 마지막 단계 afterEach, afterAll 의 테스트 구조를 잘 짜야한다.
> - 테스트 단계 안에서는 테스트를 위한 준비(Arrange or Given) / 실행(Act or When) / 검증(Assert or Then) 하는 단계로 나뉜다.
> - Given > 준비과정을 재사용 / When 의도적으로 실패하기 / THen 가장 마지막에

### 좋은 테스트의 원칙

#### FIRST

> **F**ast : 느린것에 대한 의존성 낮추기 > 파일, 데이터베이스, 네트워크를 mock 이나 stub을 사용

> **I**solated : 최소한의 유닛으로 검증하기 > 독립적이고, 집중적으로 유지

> **R**epeatable : 실행할 때마다 동일한 결과를 유지 > 환경에 영향을 받지 않도록 작성

> **S**elf-Validating : 스스로 결과를 검증하기 > 자동화를 통한 검증단계(CI/CD)

> **T**imely : 시기적절하게 테스트 코드 작성 > 사용자에게 배포되기 이전에 테스트 코드 작성

### 무엇을 해야할지 모를때의 원칙

#### Right-BICEP (모든 요구사항이 정상 동작하는지 확인 > 모든결과가 정확한지 확인)

> **Boundary Conditions** 모든 코너 케이스에 대해 테스트 하기
>
> - 잘못된 포맷의 인풋, null, 특수문자, 잘못된 이메일, 작은 숫자, 큰 숫자, 중복, 순서가 맞지 않음...

> **Inverse Relationship** 역관계를 적용해서 결과값을 확인
>
> - 일관성을 유지 (덧셈 > 뺄셈, 추가 > 제거) / ex. 덧셈의 결과는 뺄셈의 결과로 초기값이 나와야 함

> **Cross Check** 다른 수단을 이용해서 결과값이 맞는지 확인
>
> - 추가 된 과일 == 전체과일 - 예전 과일 갯수 / A알고리즘 == B알고리즘

> **Error Conditions** 불행한 경로에 대해 우아하게 처리하는가?
>
> - 네트워크 에러, 메모리 부족, 데이터베이 중지

> **Perfomance Characteristics** 성능 확인은 테스트를 통해 정확한 수치로 확인
>
> - 성능 개선의 척도와 확인도 데이터를 통해 확인

### 좋은 테스트의 커버리지

#### CORRECT

> **C**onformance : 특정 포맷을 준수 > 전화번호, 이메일, 아이디, 파일 확장자...

> **O**rdering : 순서 조건 확인하기 > 순서가 중요한 경우

> **R**ange\* : 숫자의 범위 > 제한된 범위보다 작거나 큰 경우

> **R**eference : 외부 의존성 유무, 특정한 조건의 유무 > ~일떄, ~가 되어있을떄, 어떤 특정한 상황/상태일대 이런 동작을 한다.

> **E**xistence : 값이 존재하지 않을떄 어떻게 동작? > null, undefined, "", 0

> **C**ardinality : 0-1-N 법칙에 따라 검증 > 하나도 없을떄, 하나만 있을떄, 여러개가 있을떄

> **T**ime : 상대, 절대, 동시의 일들 > 순서가 맞지 않은 경우, 소비한 시간, 지역 시간
